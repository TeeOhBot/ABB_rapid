%%%
  VERSION:1
  LANGUAGE:ENGLISH
%%%

MODULE LIB_ZYXTOOLS(SYSMODULE,NOSTEPIN)

  !*****************************************************
  ! * Copyright (C) 2014 Robert Andersson <rob@ernell.se>
  ! *
  ! * Licensed under the Apache License, Version 2.0 (the "License");
  ! * you may not use this file except in compliance with the License.
  ! * You may obtain a copy of the License at
  ! *
  ! *      http://www.apache.org/licenses/LICENSE-2.0
  ! *
  ! * Unless required by applicable law or agreed to in writing, software
  ! * distributed under the License is distributed on an "AS IS" BASIS,
  ! * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! * See the License for the specific language governing permissions and
  ! * limitations under the License.
  !*****************************************************

  !*****************************************************
  ! Module Name: LIB_ZYXTOOLS
  ! Version:     0.3
  ! Description: 
  !              - Vars & Constants
  !              - Chapter 1: misc. functions
  !              - Chapter 2: tooldata functions
  !              - Chapter 3: wobjdata functions
  !              - Chapter 4: loaddata functions
  !              - Chapter 5: zonedata functions
  !              - Chapter 6: custom move procedures
  !              
  ! Date:        2014-10-05
  ! Author:      Robert Andersson <rob@ernell.se>
  ! Internet:    http://github.com/ernell/ABB-RAPID-UTILITY-LIBRARY
  !*****************************************************

  !*****************************************************
  !
  ! Vars & Constants
  !
  !*****************************************************
  
  ! Default speeddata for movement instruktions in chapter 6
  LOCAL PERS speeddata vXYZ:=[5,10,5000,1000];

  !*****************************************************
  !
  ! Chapter 1: misc. functions
  !
  !*****************************************************

  !*****************************************************
  ! Get the normalization error from an orientation
  !*****************************************************
  FUNC num GetRotErr(orient rot)
    RETURN Abs(Sqrt(Pow(rot.q1,2)+Pow(rot.q2,2)+Pow(rot.q3,2)+Pow(rot.q4,2)));
  ENDFUNC

  !*****************************************************
  ! Normalize orientation if needed, switch for perfect orientations
  ! "NoTol" stands for "No Tolerance"
  !*****************************************************
  PROC FixOrient(INOUT orient rot,\switch NoTol)
    VAR num err;
    
    err:=GetRotErr(rot);
    IF Present(NoTol) THEN
      ! error > 0.00001 AND err <= 0.1
      ! Slightly unnormalised orientation, but still usable, fix it anyway
      IF (err>0.00001) AND (err<=0.1) rot:=NOrient(rot);
    ELSE
      ! error > 0.1 Orientation is unusable, fix it
      IF err>0.1 rot:=NOrient(rot);
    ENDIF
    ! error<=0.00001 Normalised, do nothing
  ENDPROC

  !*****************************************************
  !
  ! Chapter 2: tooldata
  !
  !*****************************************************

  !*****************************************************
  ! TCP tframe transformation in xyz
  ! Orientation is not affected
  !*****************************************************
  PROC TCPTrans(PERS tooldata pTool,num x,num y,num z)
    VAR pose poTool:=[[0,0,0],[1,0,0,0]];
    VAR pose poTrans:=[[0,0,0],[1,0,0,0]];
    VAR pose poResult:=[[0,0,0],[1,0,0,0]];

    poTool:=pTool.tframe;
    poTrans.trans.x:=x;
    poTrans.trans.y:=y;
    poTrans.trans.z:=z;
    poResult:=PoseMult(poTool,poTrans);
    pTool.tframe:=poResult;
  ENDPROC

  !*****************************************************
  ! Set orientation angle on tooldata from euler angles
  !*****************************************************
  PROC SetToolZYX(INOUT tooldata pTool,num z,num y,num x)
    pTool.tframe.rot:=OrientZYX(z,y,x);
  ENDPROC

  !*****************************************************
  ! Set orientation angle on tooldata with quaternion (orient object)
  !*****************************************************
  PROC SetToolOrient(INOUT tooldata pTool,orient value)
    pTool.tframe.rot:=value;
  ENDPROC

  !*****************************************************
  ! Get orientation from tooldata as an orient object
  !*****************************************************
  FUNC orient GetToolOrient(tooldata pTool)
    RETURN pTool.tframe.rot;
  ENDFUNC

  !*****************************************************
  ! Set mass on tooldata
  !*****************************************************
  PROC SetToolMass(INOUT tooldata pTool,num value)
    pTool.tload.mass:=value;
  ENDPROC

  !*****************************************************
  ! Get tool mass from tooldata
  !*****************************************************
  FUNC num GetToolMass(tooldata pTool)
    RETURN pTool.tload.mass;
  ENDFUNC

  !*****************************************************
  ! Set tool loaddata
  !*****************************************************
  PROC SetToolLoad(INOUT tooldata pTool,loaddata value)
    pTool.tload:=value;
  ENDPROC

  !*****************************************************
  ! Get tool loaddata
  !*****************************************************
  FUNC loaddata GetToolLoad(tooldata pTool)
    RETURN pTool.tload;
  ENDFUNC

  !*****************************************************
  ! Set Centre Of Gravity on tool loaddata
  !*****************************************************
  PROC SetToolCOG(INOUT tooldata pTool,pos value)
    pTool.tload.cog:=[value.x,value.y,value.z];
  ENDPROC

  !*****************************************************
  ! Get Centre Of Gravity from tool loaddata
  !*****************************************************
  FUNC pos GetToolCOG(tooldata pTool)
    RETURN pTool.tload.cog;
  ENDFUNC

  !*****************************************************
  ! Set tool frame translation
  !*****************************************************
  PROC SetToolFrame(INOUT tooldata pTool,num x,num y,num z)
    pTool.tframe.trans.x:=x;
    pTool.tframe.trans.y:=y;
    pTool.tframe.trans.z:=z;
  ENDPROC

  !*****************************************************
  ! Add tool frame translation
  !*****************************************************
  PROC AddToolFrame(INOUT tooldata pTool,num x,num y,num z)
    Add pTool.tframe.trans.x,x;
    Add pTool.tframe.trans.y,y;
    Add pTool.tframe.trans.z,z;
  ENDPROC

  !*****************************************************
  !
  ! Chapter 3: wobjdata
  !
  !*****************************************************

  !*****************************************************
  ! Set orientation angle on a workobject with euler angles
  !*****************************************************
  PROC SetWObjZYX(INOUT wobjdata pWObj,num z,num y,num x)
    pWObj.oframe.rot:=OrientZYX(z,y,x);
  ENDPROC

  !*****************************************************
  ! Set oframe translation
  !*****************************************************
  PROC SetWObjOFrame(INOUT wobjdata pWObj,num x,num y,num z)
    pWObj.oframe.trans.x:=x;
    pWObj.oframe.trans.y:=y;
    pWObj.oframe.trans.z:=z;
  ENDPROC

  !*****************************************************
  ! Set uframe translation
  !*****************************************************
  PROC SetWObjUFrame(INOUT wobjdata pWObj,num x,num y,num z)
    pWObj.uframe.trans.x:=x;
    pWObj.uframe.trans.y:=y;
    pWObj.uframe.trans.z:=z;
  ENDPROC

  !*****************************************************
  ! Add oframe translation
  !*****************************************************
  PROC AddWObjOFrame(INOUT wobjdata pWObj,num x,num y,num z)
    Add pWObj.oframe.trans.x,x;
    Add pWObj.oframe.trans.y,y;
    Add pWObj.oframe.trans.z,z;
  ENDPROC

  !*****************************************************
  ! Add uframe translation
  !*****************************************************
  PROC AddWObjUFrame(INOUT wobjdata pWObj,num x,num y,num z)
    Add pWObj.uframe.trans.x,x;
    Add pWObj.uframe.trans.y,y;
    Add pWObj.uframe.trans.z,z;
  ENDPROC
   
  !*****************************************************
  !
  ! Chapter 4: loaddata
  !
  !*****************************************************

  !*****************************************************
  ! Set Centre Of Gravity on loaddata
  !*****************************************************
  PROC SetLoadCOG(INOUT loaddata pLoad,pos value)
    pLoad.cog:=[value.x,value.y,value.z];
  ENDPROC

  !*****************************************************
  ! Get Centre Of Gravity from loaddata as a pos
  !*****************************************************
  FUNC pos GetLoadCOG(loaddata pLoad)
    RETURN pLoad.cog;
  ENDFUNC

  !*****************************************************
  ! Set loaddata mass
  !*****************************************************
  PROC SetLoadMass(INOUT loaddata pLoad,num value)
    pLoad.mass:=value;
  ENDPROC

  !*****************************************************
  ! Get loaddata mass
  !*****************************************************
  FUNC num GetLoadMass(loaddata pLoad)
    RETURN pLoad.mass;
  ENDFUNC

  !*****************************************************
  ! Set loaddata inertia with a pos
  !*****************************************************
  PROC SetLoadInertia(INOUT loaddata pLoad,pos pPos)
    pLoad.ix:=pPos.x;
    pLoad.iy:=pPos.y;
    pLoad.iz:=pPos.z;
  ENDPROC

  !*****************************************************
  ! Get loaddata inertia as a pos
  !*****************************************************
  FUNC pos GetLoadInertia(loaddata pLoad)
    VAR pos inertia:=[0,0,0];
    
    inertia.x:=pLoad.ix;
    inertia.y:=pLoad.iy;
    inertia.z:=pLoad.iz;
    RETURN inertia;
  ENDFUNC

  !*****************************************************
  !
  ! Chapter 5: zonedata
  !
  !*****************************************************

  !*****************************************************
  ! Set zone as "Fine point"
  !*****************************************************
  PROC SetZoneFine(INOUT zonedata pZone)
    pZone.finep:=TRUE;
  ENDPROC

  !*****************************************************
  ! Set zone as "Fly by"
  !*****************************************************
  PROC SetZoneFlyby(INOUT zonedata pZone)
    pZone.finep:=FALSE;
  ENDPROC

  !*****************************************************
  ! Path zone TCP
  !*****************************************************
  PROC SetPZoneTCP(INOUT zonedata pZone,num value)
    pZone.pzone_tcp:=value;
  ENDPROC

  !*****************************************************
  ! Path zone orientation
  !*****************************************************
  PROC SetPZoneOrient(INOUT zonedata pZone,num value)
    pZone.pzone_ori:=value;
  ENDPROC

  !*****************************************************
  ! Path zone orientation external axes
  !*****************************************************
  PROC SetPZoneEAx(INOUT zonedata pZone,num value)
    pZone.pzone_eax:=value;
  ENDPROC

  !*****************************************************
  ! Zone orientation
  !*****************************************************
  PROC SetZoneOrient(INOUT zonedata pZone,num value)
    pZone.zone_ori:=value;
  ENDPROC

  !*****************************************************
  ! Zone linear external axes
  !*****************************************************
  PROC SetZoneLEAx(INOUT zonedata pZone,num value)
    pZone.zone_leax:=value;
  ENDPROC

  !*****************************************************
  ! Zone rotational external axes
  !*****************************************************
  PROC SetZoneREAx(INOUT zonedata pZone,num value)
    pZone.zone_reax:=value;
  ENDPROC

  !*****************************************************
  !
  ! Chapter 6: reltool move procedures
  !
  !*****************************************************

  !*****************************************************
  ! Rotate around tool X-axis
  !*****************************************************
  PROC ToolRotX(INOUT tooldata pTool,num rot_x)
    ToolRot pTool,rot_x,0,0;
  ENDPROC

  !*****************************************************
  ! Rotate around tool Y-axis
  !*****************************************************
  PROC ToolRotY(INOUT tooldata pTool,num rot_y)
    ToolRot pTool,0,rot_y,0;
  ENDPROC

  !*****************************************************
  ! Rotate around tool Z-axis
  !*****************************************************
  PROC ToolRotZ(INOUT tooldata pTool,num rot_z)
    ToolRot pTool,0,0,rot_z;
  ENDPROC

  !*****************************************************
  ! Rotate around tool X+Y+Z-axis
  !*****************************************************
  PROC ToolRot(INOUT tooldata pTool,num rot_x,num rot_y,num rot_z)
    VAR robtarget current_pos;
    
    current_pos:=CRobT(\Tool:=pTool\WObj:=wobj0);
    current_pos:=CRobT(\Tool:=pTool\WObj:=wobj0);
    ConfL \Off;
    MoveL RelTool (current_pos, 0, 0, 0 \Rx:=rot_x\Ry:=rot_y\Rz:=rot_z), vXYZ, fine, pTool;
    ConfL \On;
  ENDPROC

  !*****************************************************
  ! Move TCP linear in XYZ-axis
  !*****************************************************
  PROC ToolXYZ(INOUT tooldata pTool,num trans_x,num trans_y,num trans_z)
    VAR robtarget current_pos;
    
    current_pos:=CRobT(\Tool:=pTool\WObj:=wobj0);
    current_pos:=CRobT(\Tool:=pTool\WObj:=wobj0);
    ConfL \Off;
    MoveL RelTool (current_pos, trans_x,trans_y,trans_z), vXYZ, fine, pTool;
    ConfL \On;
  ENDPROC

  !*****************************************************
  ! Can we reach the robtarget with the specified tool/wobj
  ! workobject is optional
  !*****************************************************
  FUNC bool IsReachable(robtarget pTarget,PERS tooldata pTool,\PERS wobjdata WObj)
    VAR bool result:=TRUE;
    VAR jointtarget tJoints;
    
    tJoints:=CalcJointT(pTarget,pTool \WObj?WObj);
    RETURN result;
  ERROR
    IF ERRNO=ERR_ROBLIMIT THEN
      SkipWarn;
      result:=FALSE;
      TRYNEXT;
    ENDIF
  ENDFUNC
ENDMODULE
