%%%
  VERSION:1
  LANGUAGE:ENGLISH
%%%

MODULE LIB_VECTOR(SYSMODULE,NOSTEPIN)

  !*****************************************************
  ! * Copyright (C) 2013 Robert Andersson <rob@ernell.se>
  ! *
  ! * Licensed under the Apache License, Version 2.0 (the "License");
  ! * you may not use this file except in compliance with the License.
  ! * You may obtain a copy of the License at
  ! *
  ! *      http://www.apache.org/licenses/LICENSE-2.0
  ! *
  ! * Unless required by applicable law or agreed to in writing, software
  ! * distributed under the License is distributed on an "AS IS" BASIS,
  ! * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! * See the License for the specific language governing permissions and
  ! * limitations under the License.
  !*****************************************************

  !*****************************************************
  ! Module Name: LIB_VECTOR
  ! Version:     0.1b (not yet tested)
  ! Description: Vector type
  !              - Various functions that use vector type
  !              -
  !              -
  ! Date:        2013-12-22
  ! Author:      Robert Andersson <rob@ernell.se>
  ! Internet:    http://github.com/ernell/ABB-RAPID-UTILITY-LIBRARY
  !*****************************************************

  !*****************************************************
  ! Vector type with x and y components
  !*****************************************************
  RECORD Vector
      num x;
      num y;
  ENDRECORD

  !*****************************************************
  ! Compare with +/- tolerance.
  ! Example:
  !           bool result:=cmp(100,101);
  !           result will be FALSE
  !
  !           bool result:=cmp(100,101\tol:=1);
  !           result will be TRUE, since 100 fits within limits (100-102)
  !           
  !           Tolerance is applied on second value.
  !*****************************************************
  LOCAL FUNC bool cmp(num value1,num value2,\num tol)
    VAR num tolerance;
    
    IF Present(tol) THEN
      IF value1>=(value2-tol) AND value1<=(value2+tol) RETURN TRUE;
      RETURN FALSE;
    ENDIF
    IF value1=value2 RETURN TRUE;
    RETURN FALSE;
  ENDFUNC

  !*****************************************************
  ! Distance between two vector coordinates
  !*****************************************************
  FUNC num vector_dist(Vector vec1,Vector vec2)
    RETURN Sqrt(Pow(vec1.x-vec2.x,2)+Pow(vec1.y-vec2.y,2));
  ENDFUNC

  !*****************************************************
  ! Magnitude of a vector
  !*****************************************************
  FUNC num vector_magn(Vector vec)
    RETURN Sqrt(Pow(vec.x,2)+Pow(vec.y,2));
  ENDFUNC
  
  !*****************************************************
  ! Swap the values of two Vector objects
  !*****************************************************
  PROC swap_vector(INOUT Vector value1,INOUT Vector value2)
    VAR Vector tmp;

    tmp:=value1;
    value1:=value2;
    value2:=tmp;
  ENDPROC

  !*****************************************************
  ! Sort array of Vectors
  ! Switches: 
  !           X|Y  - Vector variable used for sorting, default is X
  !           A|D  - Ascending(default)|Descending
  !          SA|SD - Also sort by second variable, Ascending(default)|Descending
  !           Tol  - Tolerance on second variable. Used for sorting rows where values are not exactly the same, but within tolerance limits
  !*****************************************************
  PROC sort_vector(INOUT Vector array{*},\switch X|switch Y,\switch A|switch D,\switch SA|switch SD,\num tol)
    VAR num size;
    VAR Vector tmp;
    VAR num tolerance:=0;
    
    size:=Dim(array,1);
    
    ! Tolerance
    IF Present(tol) THEN
      tolerance:=tol;
      IF tolerance<0 tolerance:=Abs(tolerance); ! cannot allow negative values, convert to positive
    ENDIF
    
    FOR i FROM 1 TO (size-1) DO
      FOR j FROM 1 TO (size-1) DO
        IF Present(Y) THEN
          IF Present(D) THEN
            ! Y/D
            IF array{j}.y<array{j+1}.y swap_vector array{j},array{j+1}; ! descending Y
          ELSE
            ! Y/A
            IF array{j}.y>array{j+1}.y swap_vector array{j},array{j+1}; ! ascending Y
          ENDIF
          IF array{j}.y=array{j+1}.y THEN
            IF Present(SD) THEN
              ! SD. First check if not within tolerance
              IF cmp(array{j}.x,array{j+1}.x\tol:=tolerance)=FALSE THEN
                IF array{j}.x>array{j+1}.x swap_vector array{j},array{j+1};
              ENDIF
            ELSE
              ! SA. First check if not within tolerance
              IF cmp(array{j}.x,array{j+1}.x\tol:=tolerance)=FALSE THEN
                IF array{j}.x<array{j+1}.x swap_vector array{j},array{j+1};
              ENDIF
            ENDIF
          ENDIF
        ELSE
          IF Present(D) THEN
            ! X/D
            IF array{j}.x<array{j+1}.x swap_vector array{j},array{j+1}; ! descending Y
          ELSE
            ! X/A
            ! default (if no switches are used)
            IF array{j}.x>array{j+1}.x swap_vector array{j},array{j+1}; ! ascending X
          ENDIF
          ! SA/SD
          IF array{j}.x=array{j+1}.x THEN
            IF Present(SD) THEN
              ! SD. First check if not within tolerance
              IF cmp(array{j}.y,array{j+1}.y\tol:=tolerance)=FALSE THEN
                IF array{j}.y>array{j+1}.y swap_vector array{j},array{j+1};
              ENDIF
            ELSE
              ! SA. First check if not within tolerance
              IF cmp(array{j}.y,array{j+1}.y\tol:=tolerance)=FALSE THEN
                IF array{j}.y<array{j+1}.y swap_vector array{j},array{j+1};
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDFOR
    ENDFOR
  ENDPROC
  
  !*****************************************************
  ! Reverse the elements of an array of Vectors (first=last)
  !*****************************************************
  PROC rev_vector_array(INOUT Vector array{*})
    VAR Vector tmp;
    VAR num size;
    VAR num count:=0;
    
    size:=Dim(array,1);
    WHILE count<size DO
        swap_vector array{count},array{size};
        Incr count;
        Decr size;
    ENDWHILE
  ENDPROC
ENDMODULE
